/*Формулировка пазла по ссылке https://www.codingame.com/ide/puzzle/moves-in-maze*/

/*
О работе кода:
1. Считываем ширину и высоту лабиринта, сам лабиринт, находим стартовую позицию S
2. Находим кратчайшие пути
2.1) Начинаем от стартовой позиции, расстояние до себя = 0
2.2) Для каждой клетки проверяем 4 направления с учетом периодичности лабиринта
2.3) Если соседняя клетка не стена и не посещена - обновляем расстояние
3. Преобразуем расстояния в символы (0-9, A-Z) и выводим результат, 
при этом стены остаются '#', недостижимые клетки становятся '.'.
*/


#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <queue>

using namespace std;

// Функция для преобразования числа в символ (0-9, A-Z)
char toChar(int num) {
    if (num < 10) {
        return '0' + num;
    } else {
        return 'A' + (num - 10);
    }
}

int main()
{
    int w, h; //ширина и высота лабиринта
    cin >> w >> h; cin.ignore();
    
    vector<string> grid(h);  // исходный лабиринт
    pair<int, int> start;    // стартовая позиция (y, x), как в матрице (строка, столбец)
    
    // Читаем лабиринт и находим стартовую позицию
    for (int i = 0; i < h; ++i) {
        string line;
        getline(cin, line);
        grid[i] = line;
        
        for (int j = 0; j < w; ++j) {
            if (grid[i][j] == 'S') {
                start = {i, j};  // Запоминаем координаты старта
            }
        }
    }
    
    // Массив расстояний, инициализируем -1 для непосещенных клеток
    vector<vector<int>> dist(h, vector<int>(w, -1));  // dist[y][x] = расстояние от старта
    queue<pair<int, int>> q;  // координаты клеток для обработки
    
    // Начинаем с стартовой позиции
    dist[start.first][start.second] = 0;  // расстояние
    q.push(start);  // добавляем старт в очередь
    
    // Нахождения кратчайших путей с учетом периодичности
    while (!q.empty()) {
        auto [y, x] = q.front();  // текущая клетка
        q.pop();  // убираем из очереди
        
        // Возможные направления: вверх, вниз, влево, вправо
        int dx[] = {0, 0, -1, 1};  // изменения по x для каждого направления
        int dy[] = {-1, 1, 0, 0};  // изменения по y для каждого направления
        
        for (int i = 0; i < 4; ++i) {  // Проверяем все 4 направления
            // Учитываем периодичность с помощью модульной арифметики
            int ny = (y + dy[i] + h) % h;  // новая координата y 
            int nx = (x + dx[i] + w) % w;  // новая координата x 
            
            // Если это стена, пропускаем 
            if (grid[ny][nx] == '#') {
                continue; 
            }
            
            // Если уже посещена, пропускаем
            if (dist[ny][nx] != -1) {
                continue;  
            }
            
            // Обновляем расстояние (на 1 больше чем до текущей клетки)
            dist[ny][nx] = dist[y][x] + 1;
            q.push({ny, nx});  // добавляем новую клетку в очередь для обработки
        }
    }
    
    // Строим результат для вывода
    for (int i = 0; i < h; ++i) {        // проходим по всем строкам
        for (int j = 0; j < w; ++j) {    // проходим по всем столбцам
            if (grid[i][j] == '#') {
                cout << '#'; // стена
            } else if (dist[i][j] == -1) {
                cout << '.'; // недостижимая точка
            } else {
                cout << toChar(dist[i][j]); // достижимая точка - выводим расстояние в символьном формате
            }
        }
        cout << endl;  // переход на новую строку после каждой строки лабиринта
    }
    
    return 0;
}